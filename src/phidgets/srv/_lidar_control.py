"""autogenerated by genpy from phidgets/lidar_controlRequest.msg. Do not edit."""
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct


class lidar_controlRequest(genpy.Message):
  _md5sum = "acbedaa0dacc8068c8686729472cbefb"
  _type = "phidgets/lidar_controlRequest"
  _has_header = False #flag to mark the presence of a Header object
  _full_text = """bool pause
int32 pan_servo_index
int32 tilt_servo_index
int32 sensor_index
int32 no_of_sensors
int32[] sensor_type
int32[] sensor_coupling
float32 speed
float32 acceleration
float32 pan_position_left
float32 pan_position_right
float32 pan_position_left_angle_degrees
float32 pan_position_right_angle_degrees
float32 tilt_position_up
float32 tilt_position_down
float32 tilt_position_up_angle_degrees
float32 tilt_position_down_angle_degrees
int32 tilt_steps
float32 cycle_time_sec

"""
  __slots__ = ['pause','pan_servo_index','tilt_servo_index','sensor_index','no_of_sensors','sensor_type','sensor_coupling','speed','acceleration','pan_position_left','pan_position_right','pan_position_left_angle_degrees','pan_position_right_angle_degrees','tilt_position_up','tilt_position_down','tilt_position_up_angle_degrees','tilt_position_down_angle_degrees','tilt_steps','cycle_time_sec']
  _slot_types = ['bool','int32','int32','int32','int32','int32[]','int32[]','float32','float32','float32','float32','float32','float32','float32','float32','float32','float32','int32','float32']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       pause,pan_servo_index,tilt_servo_index,sensor_index,no_of_sensors,sensor_type,sensor_coupling,speed,acceleration,pan_position_left,pan_position_right,pan_position_left_angle_degrees,pan_position_right_angle_degrees,tilt_position_up,tilt_position_down,tilt_position_up_angle_degrees,tilt_position_down_angle_degrees,tilt_steps,cycle_time_sec

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(lidar_controlRequest, self).__init__(*args, **kwds)
      #message fields cannot be None, assign default values for those that are
      if self.pause is None:
        self.pause = False
      if self.pan_servo_index is None:
        self.pan_servo_index = 0
      if self.tilt_servo_index is None:
        self.tilt_servo_index = 0
      if self.sensor_index is None:
        self.sensor_index = 0
      if self.no_of_sensors is None:
        self.no_of_sensors = 0
      if self.sensor_type is None:
        self.sensor_type = []
      if self.sensor_coupling is None:
        self.sensor_coupling = []
      if self.speed is None:
        self.speed = 0.
      if self.acceleration is None:
        self.acceleration = 0.
      if self.pan_position_left is None:
        self.pan_position_left = 0.
      if self.pan_position_right is None:
        self.pan_position_right = 0.
      if self.pan_position_left_angle_degrees is None:
        self.pan_position_left_angle_degrees = 0.
      if self.pan_position_right_angle_degrees is None:
        self.pan_position_right_angle_degrees = 0.
      if self.tilt_position_up is None:
        self.tilt_position_up = 0.
      if self.tilt_position_down is None:
        self.tilt_position_down = 0.
      if self.tilt_position_up_angle_degrees is None:
        self.tilt_position_up_angle_degrees = 0.
      if self.tilt_position_down_angle_degrees is None:
        self.tilt_position_down_angle_degrees = 0.
      if self.tilt_steps is None:
        self.tilt_steps = 0
      if self.cycle_time_sec is None:
        self.cycle_time_sec = 0.
    else:
      self.pause = False
      self.pan_servo_index = 0
      self.tilt_servo_index = 0
      self.sensor_index = 0
      self.no_of_sensors = 0
      self.sensor_type = []
      self.sensor_coupling = []
      self.speed = 0.
      self.acceleration = 0.
      self.pan_position_left = 0.
      self.pan_position_right = 0.
      self.pan_position_left_angle_degrees = 0.
      self.pan_position_right_angle_degrees = 0.
      self.tilt_position_up = 0.
      self.tilt_position_down = 0.
      self.tilt_position_up_angle_degrees = 0.
      self.tilt_position_down_angle_degrees = 0.
      self.tilt_steps = 0
      self.cycle_time_sec = 0.

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self
      buff.write(_struct_B4i.pack(_x.pause, _x.pan_servo_index, _x.tilt_servo_index, _x.sensor_index, _x.no_of_sensors))
      length = len(self.sensor_type)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(struct.pack(pattern, *self.sensor_type))
      length = len(self.sensor_coupling)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(struct.pack(pattern, *self.sensor_coupling))
      _x = self
      buff.write(_struct_10fif.pack(_x.speed, _x.acceleration, _x.pan_position_left, _x.pan_position_right, _x.pan_position_left_angle_degrees, _x.pan_position_right_angle_degrees, _x.tilt_position_up, _x.tilt_position_down, _x.tilt_position_up_angle_degrees, _x.tilt_position_down_angle_degrees, _x.tilt_steps, _x.cycle_time_sec))
    except struct.error as se: self._check_types(se)
    except TypeError as te: self._check_types(te)

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    try:
      end = 0
      _x = self
      start = end
      end += 17
      (_x.pause, _x.pan_servo_index, _x.tilt_servo_index, _x.sensor_index, _x.no_of_sensors,) = _struct_B4i.unpack(str[start:end])
      self.pause = bool(self.pause)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.sensor_type = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.sensor_coupling = struct.unpack(pattern, str[start:end])
      _x = self
      start = end
      end += 48
      (_x.speed, _x.acceleration, _x.pan_position_left, _x.pan_position_right, _x.pan_position_left_angle_degrees, _x.pan_position_right_angle_degrees, _x.tilt_position_up, _x.tilt_position_down, _x.tilt_position_up_angle_degrees, _x.tilt_position_down_angle_degrees, _x.tilt_steps, _x.cycle_time_sec,) = _struct_10fif.unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e) #most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self
      buff.write(_struct_B4i.pack(_x.pause, _x.pan_servo_index, _x.tilt_servo_index, _x.sensor_index, _x.no_of_sensors))
      length = len(self.sensor_type)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(self.sensor_type.tostring())
      length = len(self.sensor_coupling)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(self.sensor_coupling.tostring())
      _x = self
      buff.write(_struct_10fif.pack(_x.speed, _x.acceleration, _x.pan_position_left, _x.pan_position_right, _x.pan_position_left_angle_degrees, _x.pan_position_right_angle_degrees, _x.tilt_position_up, _x.tilt_position_down, _x.tilt_position_up_angle_degrees, _x.tilt_position_down_angle_degrees, _x.tilt_steps, _x.cycle_time_sec))
    except struct.error as se: self._check_types(se)
    except TypeError as te: self._check_types(te)

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    try:
      end = 0
      _x = self
      start = end
      end += 17
      (_x.pause, _x.pan_servo_index, _x.tilt_servo_index, _x.sensor_index, _x.no_of_sensors,) = _struct_B4i.unpack(str[start:end])
      self.pause = bool(self.pause)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.sensor_type = numpy.frombuffer(str[start:end], dtype=numpy.int32, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.sensor_coupling = numpy.frombuffer(str[start:end], dtype=numpy.int32, count=length)
      _x = self
      start = end
      end += 48
      (_x.speed, _x.acceleration, _x.pan_position_left, _x.pan_position_right, _x.pan_position_left_angle_degrees, _x.pan_position_right_angle_degrees, _x.tilt_position_up, _x.tilt_position_down, _x.tilt_position_up_angle_degrees, _x.tilt_position_down_angle_degrees, _x.tilt_steps, _x.cycle_time_sec,) = _struct_10fif.unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e) #most likely buffer underfill

_struct_I = genpy.struct_I
_struct_B4i = struct.Struct("<B4i")
_struct_10fif = struct.Struct("<10fif")
"""autogenerated by genpy from phidgets/lidar_controlResponse.msg. Do not edit."""
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct


class lidar_controlResponse(genpy.Message):
  _md5sum = "35e806e08fe8e25fde5b4c88fa52f05b"
  _type = "phidgets/lidar_controlResponse"
  _has_header = False #flag to mark the presence of a Header object
  _full_text = """int32 ack


"""
  __slots__ = ['ack']
  _slot_types = ['int32']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       ack

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(lidar_controlResponse, self).__init__(*args, **kwds)
      #message fields cannot be None, assign default values for those that are
      if self.ack is None:
        self.ack = 0
    else:
      self.ack = 0

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      buff.write(_struct_i.pack(self.ack))
    except struct.error as se: self._check_types(se)
    except TypeError as te: self._check_types(te)

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    try:
      end = 0
      start = end
      end += 4
      (self.ack,) = _struct_i.unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e) #most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      buff.write(_struct_i.pack(self.ack))
    except struct.error as se: self._check_types(se)
    except TypeError as te: self._check_types(te)

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    try:
      end = 0
      start = end
      end += 4
      (self.ack,) = _struct_i.unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e) #most likely buffer underfill

_struct_I = genpy.struct_I
_struct_i = struct.Struct("<i")
class lidar_control(object):
  _type          = 'phidgets/lidar_control'
  _md5sum = '63541d856b007db47fcb5fb28b699f7b'
  _request_class  = lidar_controlRequest
  _response_class = lidar_controlResponse
